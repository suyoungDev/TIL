# ê°œìš”

[ë§í¬](https://www.notion.so/JS-100-2-327372e894a843cf9c9430070c1ce5da)
ì—ì„œ ë‚˜ì˜¨ ë¬¸ì œë¥¼ í’€ì–´ë³´ê³  ìˆë‹¤.
ì´ˆê¸‰ ë¬¸ì œì´ë‹¤!

ë‹¤ìŒì—ëŠ” ì—¬ê¸° ê°•ì˜ ë“¤ì–´ì•¼ì§€
[ì¸í”„ëŸ°](https://www.inflearn.com/pages/prepare-coding-test)

- {ë‚ ì§œ : 21.03.04~05, ê³µë¶€ë‚´ì—­ : 'Q51 ~ Q53'}
- {ë‚ ì§œ : 21.03.05, ê³µë¶€ë‚´ì—­ : 'Q53 ~ '}

# ë³µìŠµ ë¦¬ìŠ¤íŠ¸

- [merge-sort](#merge-sort-ê³µë¶€)
- [quick sort](#ë¬¸ì œ-52-quick-sort)
- [balanced brackets](#53-ê´„í˜¸-ë¬¸ìì—´)

# ë¬¸í’€

## ë¬¸51. merge sort

### merge sort ê³µë¶€

- ë³‘í•©ì •ë ¬ì€ ëŒ€í‘œì ì¸ ì •ë ¬ ì•Œê³ ë¦¬ì¦˜ ì¤‘ í•˜ë‚˜
- ë¦¬ìŠ¤íŠ¸ ê¸¸ì´ê°€ 0 or 1ì´ë©´ ì´ë¯¸ ì •ë ¬ëœ ê²ƒ.
- ê¸¸ì´ê°€ ê·¸ ì´ìƒì´ë©´, ì •ë ¬ë˜ì§€ ì•Šì€ ë¦¬ìŠ¤íŠ¸ì˜ ì ˆë°˜ì„ ì˜ë¼, ë¹„ìŠ·í•œ í¬ê¸°ë¡œ ë‚˜ëˆˆë‹¤
- ê° ë¦¬ìŠ¤íŠ¸ë¥¼ ë˜ ë¹„êµí•˜ì—¬ ë³‘í•©ì •ë ¬ì„ ì´ìš©í•´ ì •ë ¬í•œë‹¤. (ë°˜ë³µ)
- ë‘ê°œ ë¦¬ìŠ¤íŠ¸ë¥¼ í•˜ë‚˜ì˜ ì •ë ¬ëœ ë¦¬ìŠ¤íŠ¸ë¡œ í•©ì¹œë‹¤.

[ì°¸ê³ ](https://reactgo.com/merge-sort-algorithm-javascript/)

#### ìˆœì„œ

1. [3, 4] [2, 1]
   - ë‘˜ë¡œ ë‚˜ëˆˆ ë’¤ ê°€ì¥ ì‘ì€ chunkë¡œ ë‚˜ëˆˆë‹¤.
2. [3][4] [2][1]
3. ë‚˜ëˆˆ chunkë“¤ì„ ì •ë ¬í•˜ì—¬ í•©ì¹œë‹¤.
   - [3, 4] [1, 2]
4. index 0 ì„ ê°ê° ë¹„êµí–ˆì„ ë•Œ, 1ì´ 3ë³´ë‹¤ ì‘ìœ¼ë¯€ë¡œ ë”°ë¡œ ë¹¼ì¤€ë‹¤.
   - [3, 4] [2]
   - **sorted array**: [1]
5. ë‹¤ì‹œ index 0ì„ ê°ê° ë¹„êµí•˜ì—¬ ë”°ë¡œ ë¹¼ì¤€ë‹¤
   - [3,4] [ ]
   - **sorted array**: [1, 2]
6. **í•˜ë‚˜ì˜ ì–´ë ˆì´ê°€ ê³µë°±ì´ ëìœ¼ë¯€ë¡œ ì´ì œ í•©ì¹œë‹¤.**
   - [1, 2, 3, 4]

#### ì‹¤ì „ ì½”ë“œ

```js
function merger(left, right) {
  // arr = sorted array
  const arr = [];
  while (left.length && right.length) {
    if (left[0] < right[0]) {
      // arrayì˜ ì²«ë²ˆì§¸ ìš”ì†Œë¥¼ ë¹„êµí•˜ì—¬
      // ê·¸ì¤‘ ì‘ì€ ì²«ë²ˆì§¸ ìš”ì†Œë¥¼ ë¹¼ë‚¸ë’¤
      // sortedArrayì¸ arrì— ë„£ëŠ”ë‹¤
      arr.push(left.shift());
    } else {
      arr.push(right.shift());
    }
  }
  return [...arr, ...left, ...right];
}

const mergeSort = (array) => {
  let half = array.length / 2;

  if (array.length < 2) {
    return array;
  }

  const left = array.splice(0, half);

  return merger(mergeSort(left), mergeSort(array));
};

const arr = [10, 2, 28, 3, 1, 9, 8, 23];
console.log(mergeSort(arr));
```

## ë¬¸ì œ 52. quick sort

### ê³µë¶€: quick sort

[ì°¸ê³ ](https://reactgo.com/quicksort-algorithm-javascript/)

- í° ë°ì´í„°ì¼ ë•Œ merge sortë‚˜ heap sortë³´ë‹¤ íš¨ê³¼ì ì¸ sorting algorithm ì„

#### ìˆœì„œ

1. ë¨¼ì € pivot (ì¤‘ì‹¬ì )ì´ ë ë§Œí•œ valueë¥¼ í•´ë‹¹ ë°°ì—´ì—ì„œ ì°¾ëŠ”ë‹¤. ì•„ë¬´ê±°ë‚˜ ê°€ëŠ¥í•˜ë‹¤.
2. ë°°ì—´ì„ ëŒë©´ì„œ pivotë³´ë‹¤ ì‘ì€ê±´ left, í°ê±´ rightìœ¼ë¡œ ë‚˜ëˆ ì¤€ë‹¤.
3. ì¬ê·€ì ìœ¼ë¡œ **right ë¶€ë¶„(pivotë³´ë‹¤ í° íŒŒíŠ¸)ì„ ë°˜ë³µ**í•œë‹¤.

#### ì‹¤ì „ ì½”ë“œ

```js
const quickSort = (array) => {
  // ê¸°ì´ˆ ë¶€ë¶„
  if (array.length < 2) {
    return array;
  }

  // pivotì€ ì•„ë¬´ê²ƒì´ë‚˜ ê°€ëŠ¥í•˜ë‹¤.
  const pivot = array[array.length - 1];
  let left = [];
  let right = [];

  const len = array.length - 1;

  let index = 0;
  while (index < len) {
    if (array[index] < pivot) {
      left.push(array[index]);
    } else {
      right.push(array[index]);
    }
    index++;
  }

  // ì¬ê·€ë¡œ ë°˜ë³µí•´ì¤˜ì•¼í•œë‹¤
  return [...quickSort(left), pivot, ...quickSort(right)];
  // pivotì€ ì´ë ‡ê²Œ ë”°ë¡œ ë‘ ìœ¼ë¡œì¨,
  // ë§¤ë²ˆ ì¬ê·€ë¥¼ í• ë•Œ ë§ˆë‹¤ í•´ë‹¹í•˜ëŠ” pivotì´ ìƒˆë¡œìš´ ìˆ«ìê°€ ëœë‹¤!
};

const arr = [10, 2, 28, 3, 1, 9, 8, 23];
console.log(quickSort(arr));
```

## 53. ê´„í˜¸ ë¬¸ìì—´

- `()`
- `{}`
- `[]`
- ì™€ ê°™ì´ ì§ì´ ë§ì„ ë•Œ YES
- `())`, `[[]`, `{})`
- ì²˜ëŸ¼ ì§ì´ ë§ì§€ ì•Šì„ ë•Œ No ë¥¼ ë¦¬í„´

### í’€ì´

```js
const guessing = (string) => {
  let brackets = string.split('');
  let count = 0;

  // ì¼ë‹¨ ì§ì´ ë§ëŠ”ì§€ í™•ì¸í•œë‹¤ '0'ì´ë©´ ì§ì´ ë§ëŠ” ê²ƒ
  for (let i = 0; i < brackets.length; i++) {
    if (brackets[i] === '(') {
      count++;
    }
    if (brackets[i] === ')') {
      count--;
    }
  }

  if (count !== 0) {
    return false;
  }

  // ì´ê²ƒë„ ì§ì´ ë§ëŠ”ì§€ í™•ì¸í•˜ëŠ” ë°©ë²• 2
  let arrayForCheck = [];
  for (let i in brackets) {
    if (brackets[i] === '(') {
      arrayForCheck.push('(');
    }
    if (brackets[i] === ')') {
      if (bracket.length === 0) {
        return false;
      }
      arrayForCheck.pop();
    }
  }
  return true;
};

const str = '((())))';
console.log(guessing(str));
```

### ê³µë¶€ balanced brackets in javascript

#### ë°©ë²• 1.

```js
const guessing = (str) => {
  if (str.length < 2) {
    return false;
  }

  let matchingOpeningBracket;
  let c;
  let stack = [];

  let openingBrackets = ['[', '{', '('];
  let closingBrackets = [']', '}', ')'];

  for (let i = 0; i < str.length; i++) {
    c = str[i];

    //  cê°€ closing ì´ë¼ë©´
    if (closingBrackets.indexOf(c) > -1) {
      // matching í• ë‹¹ : cì˜ ê´„í˜¸ ìŠ¤íƒ€ì¼(ì†Œ.ì¤‘.ëŒ€) ê°€ ë§ëŠ”ì§€ í™•ì¸í•´ë³´ê¸° ìœ„í•´
      // ê°™ì€ ìŠ¤íƒ€ì¼ì˜ ì˜¤í”„ë‹ì„ matcingì— ë„£ëŠ”ë‹¤
      matchingOpeningBracket = openingBrackets[closingBrackets.indexOf(c)];
      // closingì´ ìˆëŠ”ë° stackì€ ì—†ë‹¤? ê·¸ëŸ¼ false
      // ê°€ì¥ ì²˜ìŒì— ë„£ì€ stackê³¼ stringì˜ ì œì¼ ë§ˆì§€ë§‰ì˜ closingì„ ë¹„êµí•´ì„œ ì•„ë‹ˆë‹¤? false
      if (stack.length == 0 || stack.pop() != matchingOpeningBracket) {
        return false;
      }
    } else {
      // cê°€ openingì´ë¼ë©´
      // stackì— opening ì„ ë„£ìŒ
      stack.push(c);
    }
  }

  return stack.length == 0;
};

const str = '((({}){))';
console.log(guessing(str));
```

#### ë°©ë²•2. - ìƒˆë¡œìš´ ìë£Œêµ¬ì¡°ì¸ mapì„ ì‚¬ìš©í•œ

##### Map ê³µë¶€

- ES6ì—ì„œ ì†Œê°œëœ **ìƒˆë¡œìš´ ìë£Œêµ¬ì¡°ì¸ Map**ì„ ì‚¬ìš©í•œë‹¤
- [mdn map ì°¸ê³ ](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Map)
- Map ê°ì²´ëŠ” í‚¤-ê°’ ìŒì„ ì €ì¥í•˜ë©° ê° ìŒì˜ ì‚½ì… ìˆœì„œë„ ê¸°ì–µí•˜ëŠ” ì½œë ‰ì…˜ì…ë‹ˆë‹¤. ì•„ë¬´ ê°’(ê°ì²´ì™€ ì›ì‹œ ê°’)ì´ë¼ë„ í‚¤ì™€ ê°’ìœ¼ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
- ëª…ì‹œì ìœ¼ë¡œ ì œê³µí•œ í‚¤ ì™¸ì— ì–´ë– í•œ í‚¤ë„ ì—†ìŒ (ì˜ë„ì¹˜ ì•Šì€ í‚¤ ì—†ìŒ)
- Mapì˜ í‚¤ëŠ” í•¨ìˆ˜, ê°ì²´ ë“±ì„ í¬í•¨í•œ ëª¨ë“  í‚¤ ê°€ëŠ¥
  - ObjectëŠ” string ë˜ëŠ” symbolì´ì–´ì•¼í•¨
- Mapì˜ í‚¤ëŠ” ì •ë ¬ì´ ê°€ëŠ¥í•¨. ìˆœíšŒëŠ” ì‚½ì… ìˆœìœ¼ë¡œ ì´ë¤„ì§
  - ObjectëŠ” ì •ë ¬ë˜ì§€ ì•ŠìŒ
- Map.prototype.sizeë¥¼ í†µí•´ ì‰½ê²Œ í•­ëª©ìˆ˜ë¥¼ ì•Œì•„ ë‚¼ ìˆ˜ ìˆìŒ
- Mapì€ ìˆœíšŒê°€ëŠ¥ í•˜ë¯€ë¡œ ë°”ë¡œ ìˆœíšŒ í•  ìˆ˜ ìˆìŒ.
  - Objectë¥¼ ìˆœíšŒí•˜ë ¤ë©´ ë¨¼ì € ëª¨ë“  í‚¤ë¥¼ ì•Œì•„ë‚¸ í›„, ê·¸ í‚¤ì˜ ë°°ì—´ì„ ìˆœíšŒí•´ì•¼ í•©ë‹ˆë‹¤.
- ì¦ì€ í‚¤-ê°’ ìŒì˜ ì¶”ê°€ì™€ ì œê±°ì—ì„œ ë” ì¢‹ì€ ì„±ëŠ¥ì„ ë³´ì„.

```js
function braces(values) {
  let i;
  let result = [];
  let len = values.length;

  for (i = 0; i < len; i++) {
    if (isBalanced(values[i])) {
      result.push('YES');
    } else {
      result.push('NO');
    }
  }
  return result;
}

function isBalanced(str) {
  let i, ch;

  let bracketsMap = new Map();
  // closingìœ¼ë¡œ ê²€ìƒ‰í•  ê²ƒì´ë¯€ë¡œ keyê°€ closingì´ ë˜ì–´ì•¼í•¨
  bracketsMap.set(']', '[');
  bracketsMap.set('}', '{');
  bracketsMap.set(')', '(');
  let closingBrackets = [...bracketsMap.keys()];
  let openingBrackets = [...bracketsMap.values()];

  let temp = [];
  let len = str.length;

  for (i = 0; i < len; i++) {
    ch = str[i];

    // í•´ë‹¹ chê°€ openingì´ë¼ë©´
    if (openingBrackets.indexOf(ch) > -1) {
      // tempì— ì¶”ê°€
      temp.push(ch);

      // í•´ë‹¹ chê°€ closing ì´ë¼ë©´
    } else if (closingBrackets.indexOf(ch) > -1) {
      // í•´ë‹¹ chë¥¼ mapì—ì„œ closingìœ¼ë¡œ ê²€ìƒ‰í•´ì„œ ë‚˜ì˜¨ openingì„ í• ë‹¹
      let expectedBracket = bracketsMap.get(ch);
      // ë§Œì•½ tempì— openingì´ ì—†ê³  ì œì¼
      // ìµœê·¼ì— ì°¾ì•„ ë„£ì€ openingê³¼ (í˜„ì¬) closing chê°€ ë™ì¼í•œ ìŠ¤íƒ€ì¼ì´ ì•„ë‹ˆë¼ë©´
      // ë‹¤ë¥´ë©´ (} ì´ë ‡ê²Œ ì“´ ê²ƒ ì¼ í…Œë‹ˆê¹Œ
      if (temp.length === 0 || temp.pop() !== expectedBracket) {
        return false;
      }
    } else {
      // openingë„ closingë„ ì•„ë‹ˆë©´ ë„˜ì–´ê°€ê¸°
      continue;
    }
  }

  // for loopì„ ë‹¤ëŒì•˜ì„ ë•Œ tempê°€ ë¹„ì–´ìˆë‹¤ë©´
  // === closingì¼ë•Œ tempë¥¼ ë‹¤ ë¹¼ê°”ìœ¼ë¯€ë¡œ ì§ì´ ìˆë‹¤ë©´
  // true ë°˜í™˜
  // ì§ì´ ì—†ì–´ì„œ openingì´ ë‚¨ì•˜ë‹¤ë©´ falseë¡œ ë°˜í™˜
  return temp.length === 0;
}

var i1 = ['{}[]()', '{[}]'];

var i2 = [
  '{[}]',
  '[{()()}({[]})]({}[({})])((((((()[])){}))[]{{{({({({{{{{{}}}}}})})})}}}))[][][]',
  '{}[]()',
];

console.log(braces(i1)); // ["YES","NO"]
console.log(braces(i2)); // ["NO","YES","YES"]
```

#### ë°©ë²•3. object ì´ìš©

ì´ê²Œ ë” ê°„ë‹¨í•˜ê³  ì½ê¸°ì—ë„ ì‰¬ìš´ ì¢‹ì€ ì†”ë£¨ì…˜ ê°™ë‹¤ ğŸ¤”

```js
function isBalanced(str) {
  let bracket = {
    '{': '}',
    '(': ')',
    '[': ']',
  };

  let heap = [];
  for (let char of str) {
    // if opening : closing ìŒì´ ì¡´ì¬í•œë‹¤ë©´
    if (bracket[char]) {
      // closingì„ haepì— ë„£ê¸°
      heap.push(bracket[char]);

      // openingì´ ì•„ë‹ˆë¼ë©´ === closingì´ë¼ë©´
    } else {
      if (heap.pop() !== char) return false;
    }
  }
  return !heap.length;
}

var i1 = '{}[]';

console.log(isBalanced(i1));
```

## ë¬¸ì œ 54: ì—°ì†ë˜ëŠ” ìˆ˜

ìˆ«ìì˜ ì—´ì´ ì—°ì†ë˜ëŠ” ìˆ˜ì¸ì§€ ì•„ë‹Œì§€ í™•ì¸í•  ê²ƒ

### ë‚´ê°€ í’ˆ

ë­”ê°€ ì¢€ ê·¸ë˜ ğŸ¤”

```js
function numbersToGoing(str) {
  let array = str.split(' ').map((str) => parseInt(str, 10));

  for (let i = 0; i < array.length; i++) {
    if (array[i] < array[i + 1]) {
      let left = array[i];
      let right = array[i + 1];

      if (right !== left + 1) {
        return false;
      }
    } else if ((i = array.length - 1)) {
      return true;
    } else {
      return false;
    }
  }
}

var i1 = '1 2 3 4 5';

console.log(numbersToGoing(i1)); // ["YES","NO"]
```

### ë‹µì•ˆ

```js
function isBalanced(str) {
  let array = str.split(' ').map((str) => parseInt(str, 10));

  // ë§ˆì§€ë§‰ ì‹œë„ëŠ” ì–´ì§œí”¼ ê·¸ ì•ë‹¨ì—ì„œ í•´ê²°í•˜ë‹ˆê¹Œ -1ë¡œ í•´ê²°
  for (let i = 0; i < array.length - 1; i++) {
    // falseë¶€í„° ì ëŠ”ê²Œ ë¹ ë¥¸ê±´ë° ã…  ì•„ì‰½ë‹¤!
    if (array[i] + 1 !== array[i + 1]) {
      return 'NO';
    }
  }
  return 'Yes';
}

var i1 = '1 2 3 4 5';

console.log(isBalanced(i1)); // ["YES","NO"]
```

## ë¬¸ì œ 55. í•˜ë…¸ì´ì˜ íƒ‘

```js
function hanoi(num, start, end, temp) {
  return Math.pow(2, num) - 1;
}

console.log(hanoi(3, 'A', 'B', 'C'));
```

ìˆ˜í•™ê³µì‹ ì´ìš©í•´~~ ì†Œë¦¬ì§ˆëŸ¬~~~ ğŸ’ƒ

### í•´ë‹µ?

```js
let route = 0;

function stepsToSolveHanoiT(height, srcP, desP, bufferP) {
  if (height >= 1) {
    // Move a tower of height-1 to the buffer peg, using the destination peg.
    stepsToSolveHanoiT(height - 1, srcP, bufferP, desP);

    // Move the remaining disk to the destination peg.
    console.log('Move disk from Tower ', srcP, ' to Tower ', desP);
    route += 1;
    // Move the tower of `height-1` from the `buffer peg` to the `destination peg` using the `source peg`.
    stepsToSolveHanoiT(height - 1, bufferP, desP, srcP);
  }

  return route;
}

console.log(stepsToSolveHanoiT(5, 'A', 'C', 'B'));
```
